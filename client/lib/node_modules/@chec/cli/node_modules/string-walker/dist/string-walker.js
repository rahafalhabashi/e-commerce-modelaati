"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StringWalker = void 0;
/**
 * Class with methods to navigate within a string
 */
class StringWalker {
    /**
     * Constructor
     *
     * @param data The string to operate on
     * @param normalizeWhiteSpace If `true` newline characters will be normalized
     * to only consist of `\n`. Default is `false`.
     */
    constructor(data, normalizeWhiteSpace = false) {
        if (data instanceof Buffer) {
            data = data.toString('utf8');
        }
        if (normalizeWhiteSpace) {
            data = data.replace('\r\n', '\n').replace('\r', '\n');
        }
        this.data = data;
        this.len = this.data.length;
        this.cursor = 0;
    }
    /** Property getter for the current position within the string */
    get position() {
        return this.cursor;
    }
    /** Property getter for the length of the string */
    get length() {
        return this.len;
    }
    /** Check if the the cursor is at the end of the string */
    isEof() {
        return this.cursor >= this.len;
    }
    /**
     * Moves the cursor to the next position and returns the character code
     * of the new position
     *
     * @see StringWalker.nextChar()
     *
     * @returns The character code of the new position. If the next position is
     * the end of the string `NaN` is returned
     */
    next() {
        if (this.cursor + 1 > this.len) {
            return NaN;
        }
        this.cursor += 1;
        return this.data.charCodeAt(this.cursor);
    }
    /**
     * @see StringWalker.next()
     *
     * @returns The character at the new position. If the next position is the
     * end of the string `undefined` is returned
     */
    nextChar() {
        if (this.cursor + 1 > this.len) {
            return undefined;
        }
        this.cursor += 1;
        return this.data.charAt(this.cursor);
    }
    /**
     * Returns the character code of the current position
     */
    current() {
        return this.data.charCodeAt(this.cursor);
    }
    /**
     * Returns the character of the current position
     */
    currentChar() {
        return this.data.charAt(this.cursor);
    }
    /**
     * Look `n` (default `1`) number of characters ahead of the current position
     *
     * @example
     * const s = new StringWalker('lorem ipsum')
     * s.peek()   // > 111 (o)
     * s.peek(2)  // > 114 (r)
     * s.peek(3)  // > 101 (e)
     * s.peek(99) // > NaN
     *
     * @param n Number of characters to peek
     * @returns The character code of the peeked positon, or `NaN` if peeking
     * beyond the end of the string
     */
    peek(n = 1) {
        if (this.cursor + n >= this.len) {
            return NaN;
        }
        return this.data.charCodeAt(this.cursor + n);
    }
    /**
     * @see StringWalker.peek()
     * @returns The character of the peeked positon, or `undefined` if peeking
     * beyond the end of the string
     */
    peekChar(n = 1) {
        if (this.cursor + n >= this.len) {
            return undefined;
        }
        return this.data.charAt(this.cursor + n);
    }
    /**
     * Look `n` (default `1`) number of characters behind the current position.
     * @param n Number of characters to look behind
     * @returns The character code of the look behind character, or `NaN` if
     * looking before the start of the string
     */
    behind(n = 1) {
        n = n || 1;
        if (this.cursor - n < 0) {
            return NaN;
        }
        return this.data.charCodeAt(this.cursor - n);
    }
    /**
     * @see StringWalker.behind()
     * @returns The character code of the look behind character, or `NaN` if
     * looking before the start of the string
     */
    behindChar(n = 1) {
        n = n || 1;
        if (this.cursor - n < 0) {
            return undefined;
        }
        return this.data.charAt(this.cursor - n);
    }
    /**
     * Find the position of `char`
     *
     * @note This method does not move the position within the string
     *
     * @example
     * const s = new StringWalker('lorem ipsum')
     * s.findNext(' ') // > 4
     *
     * @see StringWalker.findNextOf()
     * @param char Either a character or a character code
     * @throws An error is thrown if `char` is a string of length other than `1`
     * @returns The position of `char`, or `NaN` if `char` was not found
     */
    findNext(char) {
        if (typeof char === 'string') {
            if (char.length !== 1) {
                throw new Error('findNext() expected a single character');
            }
            char = char.charCodeAt(0);
        }
        let i = this.cursor + 1;
        do {
            const k = this.data.charCodeAt(i);
            if (k === char) {
                return i;
            }
            i += 1;
        } while (i < this.len);
        return NaN;
    }
    /**
     * Find the next position of either of `chars`
     *
     * @see StringWalker.findNext()
     *
     * @example
     * const s = new StringWalker('lorem ipsum')
     * s.findNextOf(['s', 'e']) // > 3 (position of e)
     *
     * @param chars List of characters to search for. This can either be
     * characters or character codes
     * @throws An error is thrown if `chars` contains a string of length
     * other than `1`
     * @returns The position of the first found character, or `NaN` if none was
     * found
     */
    findNextOf(chars) {
        const x = chars.map((c) => {
            if (typeof c === 'string') {
                if (c.length > 1) {
                    throw new Error(`findNextOf() expects single characters, got ${c}`);
                }
                return c.charCodeAt(0);
            }
            return c;
        });
        let i = this.cursor + 1;
        do {
            const k = this.data.charCodeAt(i);
            if (x.includes(k)) {
                return i;
            }
            i += 1;
        } while (i < this.length);
        return NaN;
    }
    /**
     * Move the internal cursor by `steps` number of positions
     * @param steps Steps to move the cursor by
     * @throws An error if the cursor will move beyond the end, or before
     * the start, of the string
     */
    moveBy(steps) {
        this.assertSaneStart(this.cursor + steps);
        this.assertSaneEnd(this.cursor + steps);
        this.cursor += steps;
        return this;
    }
    /**
     * Move the internal cursor to the postion `to`
     * @param to Position to move the cursor to
     * @throws An error if the cursor will move beyond the end, or before
     * the start, of the string
     */
    moveTo(to) {
        this.assertSaneStart(to);
        this.assertSaneEnd(to);
        this.cursor = to;
        return this;
    }
    /**
     * Returns the character code of the character at position `pos`
     * @param pos The position to get the character code for
     */
    at(pos) {
        return this.data.charCodeAt(pos);
    }
    /**
     * Returns the character at position `pos`
     * @param pos The position to get the character of
     */
    charAt(pos) {
        return this.data.charAt(pos);
    }
    /**
     * Moves the internal cursor forward as long as any character in `char` is
     * consecutively found
     *
     * @example
     * // Consume all consecutive whitespace
     * const s = new StringWalker('lorem \t\n ipsum')
     * const spacePos = s.findNext(' ')
     * s.moveTo(spacePos).consume([' ', '\n', '\t'])
     * // Now the cursor is at 'i'.
     *
     * @param char A character, character code or array of these
     */
    consume(char) {
        if (!Array.isArray(char)) {
            if (typeof char === 'string') {
                char = char.charCodeAt(0);
            }
            char = [char];
        }
        const chars = char.map((c) => {
            return typeof c === 'string' ? c.charCodeAt(0) : c;
        });
        const d = this.data;
        while (chars.includes(d.charCodeAt(this.cursor))) {
            this.cursor += 1;
            if (this.isEof()) {
                break;
            }
        }
        return this;
    }
    /**
     * Reset the internal cursor to position `0`
     */
    rewind() {
        this.cursor = 0;
        return this;
    }
    /**
     * Returns the substring from `from` to `to`. This behaves the same as
     * JavaScripts native `substring()`
     *
     * @throws An error is throws if either `from` is greater than `to`, from
     * is less than `0` or `to` is greater than the string length
     *
     * @returns The substring of `from` to `to`
     */
    substring(from, to) {
        if (!to) {
            to = this.length;
        }
        if (from > to) {
            throw new Error(`from (${from}) can not be greater than (${to})`);
        }
        this.assertSaneStart(from);
        this.assertSaneEnd(to);
        return this.data.substring(from, to);
    }
    /**
     * Throws an error if `n` is less than `0`
     * @param n
     */
    assertSaneStart(n) {
        if (n < 0) {
            throw new Error(`Start position ${n} is less than zero`);
        }
    }
    /**
     * Throws an error if `n` is greater than {@see StringWalker#length}
     * @param n
     */
    assertSaneEnd(n) {
        if (n > this.len) {
            throw new Error(`End position ${n} is greater than the string length ${this.len}`);
        }
    }
}
exports.StringWalker = StringWalker;
//# sourceMappingURL=string-walker.js.map