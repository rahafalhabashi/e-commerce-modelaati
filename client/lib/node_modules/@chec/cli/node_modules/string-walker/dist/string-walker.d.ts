/// <reference types="node" />
declare type Maybe<T> = T | undefined;
/**
 * Class with methods to navigate within a string
 */
export declare class StringWalker {
    /** The string to operate on */
    protected readonly data: string;
    /** The length of the string */
    protected len: number;
    /** Current position within the string */
    protected cursor: number;
    /**
     * Constructor
     *
     * @param data The string to operate on
     * @param normalizeWhiteSpace If `true` newline characters will be normalized
     * to only consist of `\n`. Default is `false`.
     */
    constructor(data: string | Buffer, normalizeWhiteSpace?: boolean);
    /** Property getter for the current position within the string */
    get position(): number;
    /** Property getter for the length of the string */
    get length(): number;
    /** Check if the the cursor is at the end of the string */
    isEof(): boolean;
    /**
     * Moves the cursor to the next position and returns the character code
     * of the new position
     *
     * @see StringWalker.nextChar()
     *
     * @returns The character code of the new position. If the next position is
     * the end of the string `NaN` is returned
     */
    next(): number;
    /**
     * @see StringWalker.next()
     *
     * @returns The character at the new position. If the next position is the
     * end of the string `undefined` is returned
     */
    nextChar(): Maybe<string>;
    /**
     * Returns the character code of the current position
     */
    current(): number;
    /**
     * Returns the character of the current position
     */
    currentChar(): string;
    /**
     * Look `n` (default `1`) number of characters ahead of the current position
     *
     * @example
     * const s = new StringWalker('lorem ipsum')
     * s.peek()   // > 111 (o)
     * s.peek(2)  // > 114 (r)
     * s.peek(3)  // > 101 (e)
     * s.peek(99) // > NaN
     *
     * @param n Number of characters to peek
     * @returns The character code of the peeked positon, or `NaN` if peeking
     * beyond the end of the string
     */
    peek(n?: number): number;
    /**
     * @see StringWalker.peek()
     * @returns The character of the peeked positon, or `undefined` if peeking
     * beyond the end of the string
     */
    peekChar(n?: number): Maybe<string>;
    /**
     * Look `n` (default `1`) number of characters behind the current position.
     * @param n Number of characters to look behind
     * @returns The character code of the look behind character, or `NaN` if
     * looking before the start of the string
     */
    behind(n?: number): number;
    /**
     * @see StringWalker.behind()
     * @returns The character code of the look behind character, or `NaN` if
     * looking before the start of the string
     */
    behindChar(n?: number): Maybe<string>;
    /**
     * Find the position of `char`
     *
     * @note This method does not move the position within the string
     *
     * @example
     * const s = new StringWalker('lorem ipsum')
     * s.findNext(' ') // > 4
     *
     * @see StringWalker.findNextOf()
     * @param char Either a character or a character code
     * @throws An error is thrown if `char` is a string of length other than `1`
     * @returns The position of `char`, or `NaN` if `char` was not found
     */
    findNext(char: string | number): number;
    /**
     * Find the next position of either of `chars`
     *
     * @see StringWalker.findNext()
     *
     * @example
     * const s = new StringWalker('lorem ipsum')
     * s.findNextOf(['s', 'e']) // > 3 (position of e)
     *
     * @param chars List of characters to search for. This can either be
     * characters or character codes
     * @throws An error is thrown if `chars` contains a string of length
     * other than `1`
     * @returns The position of the first found character, or `NaN` if none was
     * found
     */
    findNextOf(chars: Array<string | number>): number;
    /**
     * Move the internal cursor by `steps` number of positions
     * @param steps Steps to move the cursor by
     * @throws An error if the cursor will move beyond the end, or before
     * the start, of the string
     */
    moveBy(steps: number): this;
    /**
     * Move the internal cursor to the postion `to`
     * @param to Position to move the cursor to
     * @throws An error if the cursor will move beyond the end, or before
     * the start, of the string
     */
    moveTo(to: number): this;
    /**
     * Returns the character code of the character at position `pos`
     * @param pos The position to get the character code for
     */
    at(pos: number): number;
    /**
     * Returns the character at position `pos`
     * @param pos The position to get the character of
     */
    charAt(pos: number): string;
    /**
     * Moves the internal cursor forward as long as any character in `char` is
     * consecutively found
     *
     * @example
     * // Consume all consecutive whitespace
     * const s = new StringWalker('lorem \t\n ipsum')
     * const spacePos = s.findNext(' ')
     * s.moveTo(spacePos).consume([' ', '\n', '\t'])
     * // Now the cursor is at 'i'.
     *
     * @param char A character, character code or array of these
     */
    consume(char: string | number | string[] | number[]): this;
    /**
     * Reset the internal cursor to position `0`
     */
    rewind(): this;
    /**
     * Returns the substring from `from` to `to`. This behaves the same as
     * JavaScripts native `substring()`
     *
     * @throws An error is throws if either `from` is greater than `to`, from
     * is less than `0` or `to` is greater than the string length
     *
     * @returns The substring of `from` to `to`
     */
    substring(from: number, to?: number): string;
    /**
     * Throws an error if `n` is less than `0`
     * @param n
     */
    protected assertSaneStart(n: number): void;
    /**
     * Throws an error if `n` is greater than {@see StringWalker#length}
     * @param n
     */
    protected assertSaneEnd(n: number): void;
}
export {};
